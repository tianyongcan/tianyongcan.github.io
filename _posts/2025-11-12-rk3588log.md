---
title: rk3588开发日志
date: 2025-11-12 10:30:00 +0800
categories:
tags:
pin: false
layout: post
---
# 开发板连接

板端启动可通过串口连接进入命令行，通过命令行连接开发板实现wifi连接，rk3588自带板载wifi，连接后可启动ssh连接开发板终端，可不再使用串口进行连接。

在连接实验室网络时，IP地址固定

在PC端使用ssh连接开发板，注意电脑需要与开发板在同一网络下才可实现ssh连接，连接不通请互相ping地址，注意PC端防火墙，可关闭防火墙重试，如关闭防火墙可以ping通，可以设置防火墙规则开放ssh 22号端口

ssh连接可能会有网络波动导致连接不稳定，使用串口实现板端连接是最稳定的办法

# adb传输
adb传输需要更换连接端口。
目前采用的开发方式是在服务器上进行编译，传回PC端之后与板端进行adb连接推送
模型用adb传输后需要给执行文件执行权限

```
chmod +x rknn_yolov5_cam
```

# SDK编译
SDK编译要求在ubuntu20.04环境中进行编译，由于服务器环境为22.04，导致编译过程中出现linux环境问题较多，转而使用docker创建环境

# docker使用
构建docker流程如下：
创建一个新的文件夹来存放我们的 Dockerfile
```
mkdir -p ~/rk3588_build_env cd ~/rk3588_build_env
```
**创建 Dockerfile 文件**
```
vim Dockerfile
```

```
# 使用官方的 Ubuntu 20.04 作为基础
FROM ubuntu:20.04

# 设置环境变量，避免安装时出现交互式提示
ENV DEBIAN_FRONTEND=noninteractive

# 更新apt源并安装所有手册要求的依赖
# 注意：我们在这里先不安装bison，留到后面手动安装指定版本
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    git ssh make gcc libssl-dev liblz4-tool expect expect-dev g++ patchelf \
    chrpath gawk texinfo diffstat binfmt-support qemu-user-static live-build \
    flex fakeroot cmake gcc-multilib g++-multilib unzip device-tree-compiler \
    ncurses-dev bzip2 expat gpgv2 cpp-aarch64-linux-gnu libgmp-dev libmpc-dev \
    bc python-is-python3 python2 wget \
    && rm -rf /var/lib/apt/lists/*

# 手动下载并安装一个已知可以工作的旧版本 bison (3.5.1)
RUN apt-get update && \
    apt-get install -y wget && \
    wget http://archive.ubuntu.com/ubuntu/pool/main/b/bison/bison_3.5.1+dfsg-1_amd64.deb && \
    dpkg -i bison_3.5.1+dfsg-1_amd64.deb && \
    rm bison_3.5.1+dfsg-1_amd64.deb && \
    apt-mark hold bison && \
    rm -rf /var/lib/apt/lists/*

# 创建一个非root工作用户，这更安全，也更符合SDK脚本的预期
# 同时将用户加入sudo组，方便在容器内临时提权
RUN useradd -ms /bin/bash user && \
    adduser user sudo && \
    echo "user ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers

# 切换到这个新用户
USER user
WORKDIR /home/user

# 设置默认命令，当容器启动时，给我们一个bash终端
CMD ["/bin/bash"]
```

构建docker镜像,需要修改docker下载镜像源，参考b站
```
docker build -t rk3588-build-env .
```
创建容器
```
docker run -it --name rk3588-compiler \ -v /data/user/rk3D/rk3588_linux_sdk:/home/user/rk3588_linux_sdk \ rk3588-build-env
```

| 命令            | 功能          | 示例                            |
| ------------- | ----------- | ----------------------------- |
| docker ps     | 列出当前正在运行的容器 |                               |
| docker start  | 启动已经存在的容器   | docker start rk3588-compiler  |
| docker attach | 进入容器终端      | docker attach rk3588-compiler |
| exit          | 停止容器        |                               |
# 保存docker镜像
## 方法一： Dockerfile
```
# 使用官方的 Ubuntu 20.04 作为基础
FROM ubuntu:20.04

# 设置环境变量，避免安装时出现交互式提示
ENV DEBIAN_FRONTEND=noninteractive

# 更新apt源并一次性安装所有已知依赖
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    git ssh make gcc libssl-dev liblz4-tool expect expect-dev g++ patchelf \
    chrpath gawk texinfo diffstat binfmt-support qemu-user-static live-build \
    flex fakeroot cmake gcc-multilib g++-multilib unzip device-tree-compiler \
    ncurses-dev bzip2 expat gpgv2 cpp-aarch64-linux-gnu libgmp-dev libmpc-dev \
    bc python-is-python3 python2 wget sudo \
    time file rsync patch vim-common ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# 手动下载并安装一个已知可以工作的旧版本 bison (3.5.1)
RUN apt-get update && \
    apt-get install -y wget && \
    wget http://archive.ubuntu.com/ubuntu/pool/main/b/bison/bison_3.5.1+dfsg-1_amd64.deb && \
    dpkg -i bison_3.5.1+dfsg-1_amd64.deb && \
    rm bison_3.5.1+dfsg-1_amd64.deb && \
    apt-mark hold bison && \
    rm -rf /var/lib/apt/lists/*

# 创建一个非root工作用户，并赋予sudo免密权限
RUN useradd -ms /bin/bash user && \
    adduser user sudo && \
    echo "user ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers

# 切换到这个新用户
USER user
WORKDIR /home/user

# 设置默认命令
CMD ["/bin/bash"]
```
可以用上面的文件来创造镜像
## 方法二：快照

```
docker commit rk3588-compiler rk3588-build-env:snapshot
```





# build.sh bug解决
编译打包脚本有问题，编译成功后会在对应文件夹生成软链接，实际文件在软连接对应位置存放
为了方便进行烧录，写了个脚本将对应文件汇总到output的img文件夹下
在sdk目录下运行以下命令即可
```
./collect_images.sh
```

# 镜像修改
使用ubuntu系统进行开发，需要安装ubuntu系统镜像，之前烧录的历程是build什么的镜像，无法进行开发工作
具体参考31【正点原子】ATK-DLRK3588出厂镜像烧录指导V1.1.pdf

# 开发环境选择
目前面临两个选择，第一使用buildroot进行交叉编译开发，技术强烈推荐使用该方案
其次，找到适配的linux系统镜像，ubuntu或者是debian，在该环境上进行开发工作，一种是别人已经整好的，另一种是使用SDK进行编译

# 尝试进行ubuntu系统的环境移植

## wifi修复
buildroot/output/rockchip_atk_dlrk3588/target$ find -name "8733*"  
./usr/lib/modules/8733bu.ko  
target/lib/firmware这些也拷贝 过去
首先将固件和驱动程序从SDK中拷贝到开发板，可以使用U盘进行连接
```
# 创建挂载目录（如果之前没建过） mkdir -p /mnt/usb 
# 挂载 U 盘分区 sda1 到该目录 mount /dev/sda1 /mnt/usb

ls /mnt/usb






# 1. 确保目标文件夹存在 mkdir -p /lib/modules/5.10.160/kernel/drivers/net/wireless/realtek/ 

# 2. 拷贝驱动文件 cp /mnt/usb/modules/8733bu.ko /lib/modules/5.10.160/kernel/drivers/net/wireless/realtek/

# 1. 拷贝 WiFi 固件到系统固件根目录
cp /mnt/usb/firmware/rtl8733bu_fw /lib/firmware/
cp /mnt/usb/firmware/rtl8733bu_config /lib/firmware/

# 2. 做个双保险：再复制一份带 .bin 后缀的（很多驱动默认找这个名字）
cp /lib/firmware/rtl8733bu_fw /lib/firmware/rtl8733bu_fw.bin

# 3. 拷贝 Bluetooth 固件 (顺手把蓝牙也修了)
# 如果系统里没有 rtlbt 目录就创建
mkdir -p /lib/firmware/rtlbt
# 拷贝 U 盘里的 rtlbt 文件夹内容过去
cp -r /mnt/usb/firmware/rtlbt/* /lib/firmware/rtlbt/

# 1. 更新依赖
depmod -a

# 2. 加载驱动
modprobe 8733bu

#检查映射
modprobe 8733bu

# 1. 查看内核日志（看最后几行有没有 8733 或 RTW 字样） dmesg | tail -n 20 

# 2. 查看网卡列表 ip link

# 注意把网卡名换成你那个很长的名字 ip link set wlx4ca38f7b416c up

nmcli dev wifi list

nmcli dev wifi connect "H155-381_2AC8" password "fangwei123"

# 1. 把模块名写入 /etc/modules 文件 echo "8733bu" >> /etc/modules 

# 2. 再次执行依赖更新（确保下次开机能找到） depmod -a

resize2fs /dev/mmcblk0p6

df -h


# 1. 清理之前的缓存
rm -rf /var/lib/apt/lists/*
apt clean

# 2. 重新更新列表
apt update

# 3. 安装常用工具
apt install nano -y
```

## 验证NPU

目前仍然存在一个问题， 
你的系统（阉割版）删除了内核头文件和索引文件（modules.order），所以 depmod 在建立依赖关系时找不到“花名册”，就会报警。  
后果： 开机时，系统可能无法通过 modprobe 自动加载驱动，因为它不知道驱动在哪里这个问题还没解决

```
root@ATK-DLRK3588-Ubuntu:/# ls -l /dev/rknpu*  
ls: cannot access '/dev/rknpu*': No such file or directory  
root@ATK-DLRK3588-Ubuntu:/#

  

User

root@ATK-DLRK3588-Ubuntu:/# dmesg | grep -i npu  
[ 2.108275] rk_gmac-dwmac fe1c0000.ethernet: clock input or output? (output).  
[ 2.243501] rk_gmac-dwmac fe1b0000.ethernet: clock input or output? (output).  
[ 2.542590] input: rk805 pwrkey as /devices/platform/feb20000.spi/spi_master/spi2/spi2.0/rk805-pwrkey.9. auto/input/input0  
[ 2.563404] vdd_npu_s0: supplied by vcc5v0_sys  
[ 3.241478] input: gsensor as /devices/platform/feac0000.i2c/i2c-4/4-0036/input/input1  
[ 3.297882] rkisp_hw fdcb0000.rkisp: max input:0x0@0fps  
[ 3.298504] rkisp_hw fdcc0000.rkisp: max input:0x0@0fps  
[ 3.385103] input: rockchip-hdmi0 rockchip-hdmi0 as /devices/platform/hdmi0-sound/sound/card0/input2  
[ 3.386012] input: rockchip-hdmi1 rockchip-hdmi1 as /devices/platform/hdmi1-sound/sound/card1/input3  
[ 3.386712] input: rockchip-dp0 rockchip-dp0 as /devices/platform/dp0-sound/sound/card2/input4  
[ 3.387703] input: rockchip-dp1 rockchip-dp1 as /devices/platform/dp1-sound/sound/card3/input5  
[ 3.400180] input: rockchip,hdmiin rockchip,hdmiin as /devices/platform/hdmiin-sound/sound/card4/input6  
[ 3.401390] input: headset-keys as /devices/platform/es8388-sound/input/input7  
[ 3.462053] input: rockchip-es8388 Headset as /devices/platform/es8388-sound/sound/card5/input8  
[ 3.468113] input: gyro as /devices/platform/feac0000.i2c/i2c-4/4-0036-1/input/input9  
[ 3.700570] input: adc-keys as /devices/platform/adc-keys/input/input10  
[ 4.023509] RKNPU fdab0000.npu: Adding to iommu group 0  
[ 4.023766] RKNPU fdab0000.npu: RKNPU: rknpu iommu is enabled, using iommu mode  
[ 4.025274] RKNPU fdab0000.npu: can't request region for resource [mem 0xfdab0000-0xfdabffff]  
[ 4.025312] RKNPU fdab0000.npu: can't request region for resource [mem 0xfdac0000-0xfdacffff]  
[ 4.025342] RKNPU fdab0000.npu: can't request region for resource [mem 0xfdad0000-0xfdadffff]  
[ 4.025958] [drm] Initialized rknpu 0.9.2 20231018 for fdab0000.npu on minor 1  
[ 4.030384] RKNPU fdab0000.npu: RKNPU: bin=0  
[ 4.030606] RKNPU fdab0000.npu: leakage=7  
[ 4.030745] debugfs: Directory 'fdab0000.npu-rknpu' with parent 'vdd_npu_s0' already present!  
[ 4.038385] RKNPU fdab0000.npu: pvtm=867  
[ 4.043403] RKNPU fdab0000.npu: pvtm-volt-sel=3  
[ 4.046005] RKNPU fdab0000.npu: avs=0  
[ 4.046480] RKNPU fdab0000.npu: l=10000 h=85000 hyst=5000 l_limit=0 h_limit=800000000 h_table=0  
[ 4.056763] RKNPU fdab0000.npu: failed to find power_model node  
[ 4.056849] RKNPU fdab0000.npu: RKNPU: failed to initialize power model  
[ 4.056874] RKNPU fdab0000.npu: RKNPU: failed to get dynamic-coefficient  
root@ATK-DLRK3588-Ubuntu:/#
```


## U盘挂载
```
#查看设备名
lsblk

#挂载
mount /dev/sda1 /mnt/usb

#查看文件
ls /mnt/usb

#拔出U盘
cd / # 先退出 U 盘目录，否则会提示 target is busy 
umount /mnt/usb


```

```
#驱动加载
sudo insmod /root/wifi_driver/8733bu.ko

# 1. 断开当前连接 
nmcli dev disconnect wlx4ca38f7b416c
# 1. 扫描一下确认能搜到信号（可选）
 nmcli dev wifi list 
# 2. 连接 WiFi (使用你之前提供的信息) 
nmcli dev wifi connect "Xiaomi 14" password "6410165tyc"
nmcli dev wifi connect "H155-381_2AC8" password "fangwei123"
```


太棒了！**环境验证结果完美。**

从你提供的日志来看，你的 Debian 系统状态极其健康：

1. **NPU 驱动**：`v0.9.2` 已加载，且设备节点 `/dev/dri/renderD129` 权限正确。
    
2. **NPU 运行库**：`/usr/lib/librknnrt.so` 已就位（这是 Debian 系统预装好的，不需要我们手动折腾了）。
    
3. **GPU 驱动**：`Mali G610 (g18p0)` 驱动已加载，这对后续跑 SLAM 的后端加速至关重要。
    

你现在已经跳出了“环境地狱”，可以直接进入**应用部署阶段**。

基于你的目标（SLAM + YOLO），我们需要完成最后两步软件层的验证，然后直接开始部署。

---

### 第一阶段：验证 Python NPU 接口 (YOLO 前置)

虽然底层库 (`.so`) 有了，但我们需要确认 Python 接口 (`rknn-toolkit-lite2`) 是否预装且版本匹配。

**1. 检查 Python 库状态** 请在终端执行：

Bash

```
pip3 list | grep rknn
```

- **预期结果**：应该显示 `rknn-toolkit-lite2 x.x.x`。
    
- **如果没显示**：说明系统没预装 Python 包。鉴于你的驱动是 `0.9.2`，建议直接安装我们之前用过的 **v1.5.2** 包（兼容性最好）。
    
    Bash
    
    ```
    # 如果 pip list 没东西，执行这句安装 (假设还在 U 盘里)
    pip3 install /mnt/usb/rknn_toolkit_lite2-1.5.2-cp38-cp38-linux_aarch64.whl
    ```
    

**2. 跑通“Hello World” (终极握手)** 只要这一步打印出 `[0]`，YOLO 就 100% 能跑了。

Bash

```
python3 -c "from rknnlite.api import RKNNLite; r=RKNNLite(); r.list_devices(); print('>>> NPU Ready!')"
```

---

### 第二阶段：部署 SLAM 开发环境 (利用 Debian 优势)

在 Debian 上部署 SLAM (如 ORB-SLAM3) 最大的优势是可以通过 `apt` 安装大部分数学库，**不用像 Ubuntu 那样自己编译好几个小时**。

请直接复制以下命令执行，一键配齐 SLAM 全家桶：

Bash

```
# 1. 更新软件源
sudo apt update

# 2. 安装基础编译工具
sudo apt install -y build-essential cmake git pkg-config

# 3. 安装 SLAM 核心数学库 (Eigen3, Sophus 依赖)
sudo apt install -y libeigen3-dev

# 4. 安装 OpenCV (Debian 源里的 OpenCV 通常已经支持了硬件加速)
# 这比自己编译快几个小时！
sudo apt install -y libopencv-dev python3-opencv

# 5. 安装 Pangolin 依赖 (可视化窗口)
sudo apt install -y libglew-dev libpython3-dev libpangolin-dev
```

---

### 第三阶段：下一步动作 (开始干活)

环境验证到此结束，系统已经准备好。接下来你要做的是：

1. **YOLO 部分**：
    
    - 你需要把电脑上训练好的 YOLO 模型（`.pt`）导出为 **ONNX**。
        
    - 然后用电脑上的 `rknn-toolkit2` 把 ONNX 转为 **RKNN** 文件。
        
    - **只有 RKNN 文件才能在板子的 NPU 上跑。**
        
2. **SLAM 部分**：
    
    - 你可以直接拉取 ORB-SLAM3 的代码开始编译了，因为依赖库刚才已经装好了。
        

**你要先跑 YOLO 还是先跑 SLAM？**

- **选 YOLO**：我可以给你一个 **PC 端模型转换脚本** 和 **板端推理代码** 模板。
    
- **选 SLAM**：我可以指导你如何修改 ORB-SLAM3 的 `CMakeLists.txt` 以适配 RK3588 的 OpenCV 路径。

# debian系统开发


## 环境验证
```
root@ATK-DLRK3588:~# cat /sys/kernel/debug/rknpu/version

RKNPU driver: v0.9.2

root@ATK-DLRK3588:~# ls -l /dev/dri/renderD129

crw-rw----+ 1 root render 226, 129 11月 25 06:13 /dev/dri/renderD129

root@ATK-DLRK3588:~# cat /sys/kernel/debug/rknpu/load

NPU load:  Core0:  0%, Core1:  0%, Core2:  0%,

root@ATK-DLRK3588:~# ^C

root@ATK-DLRK3588:~# # 检查库文件位置 (Debian 通常预装在系统目录)

find /usr -name "librknnrt.so"

# 预期输出：/usr/lib/aarch64-linux-gnu/librknnrt.so (或者类似路径)

/usr/lib/librknnrt.so

root@ATK-DLRK3588:~# # 检查 Mali GPU 驱动是否加载

dmesg | grep -i mali

# 预期输出：应该能看到 mali g610 相关的初始化成功日志

[    3.620969] mali fb000000.gpu: Kernel DDK version g18p0-01eac0

[    3.624197] mali fb000000.gpu: bin=0

[    3.624386] mali fb000000.gpu: leakage=12

[    3.628891] debugfs: Directory 'fb000000.gpu-mali' with parent 'vdd_gpu_s0' already present!

[    3.630762] mali fb000000.gpu: pvtm=872

[    3.631076] mali fb000000.gpu: pvtm-volt-sel=3

[    3.632441] mali fb000000.gpu: avs=0

[    3.632493] W : [File] : drivers/gpu/arm/bifrost/platform/rk/mali_kbase_config_rk.c; [Line] : 143; [Func] : kbase_platform_rk_init(); power-off-delay-ms not available.

[    3.646887] mali fb000000.gpu: r0p0 status 5 not found in HW issues table;

[    3.646907] mali fb000000.gpu: falling back to closest match: r0p0 status 0

[    3.646912] mali fb000000.gpu: Execution proceeding normally with fallback match

[    3.646918] mali fb000000.gpu: GPU identified as 0x7 arch 10.8.6 r0p0 status 0

[    3.646951] mali fb000000.gpu: No priority control manager is configured

[    3.647131] mali fb000000.gpu: No memory group manager is configured

[    3.647151] mali fb000000.gpu: Protected memory allocator not available

[    3.647749] mali fb000000.gpu: Capping CSF_FIRMWARE_TIMEOUT to CSF_FIRMWARE_PING_TIMEOUT

[    3.648187] mali fb000000.gpu: l=10000 h=85000 hyst=5000 l_limit=0 h_limit=800000000 h_table=0

[    3.662649] mali fb000000.gpu: Probed as mali0

[    4.046678] I : [File] : drivers/gpu/arm/mali400/mali/linux/mali_kernel_linux.c; [Line] : 406; [Func] : mali_module_init(); svn_rev_string_from_arm of this mali_ko is '', rk_ko_ver is '5', built at '15:45:38', on 'Jul  8 2024'.

[    4.047010] Mali:

[    4.047014] Mali device driver loaded

[   32.221646] mali fb000000.gpu: Loading Mali firmware 0x1010000

[   32.224685] mali fb000000.gpu: Mali firmware git_sha: ee476db42870778306fa8d559a605a73f13e455c



root@ATK-DLRK3588:~#

太棒了！**环境验证结果完美。**

从你提供的日志来看，你的 Debian 系统状态极其健康：

1. **NPU 驱动**：`v0.9.2` 已加载，且设备节点 `/dev/dri/renderD129` 权限正确。
    
2. **NPU 运行库**：`/usr/lib/librknnrt.so` 已就位（这是 Debian 系统预装好的，不需要我们手动折腾了）。
    
3. **GPU 驱动**：`Mali G610 (g18p0)` 驱动已加载，这对后续跑 SLAM 的后端加速至关重要。
    

你现在已经跳出了“环境地狱”，可以直接进入**应用部署阶段**。


```

看着环境是ok的，但是检查 NPU 驱动接口 (必须看到 [0])时一直有问题，但是在测试脚本时可以正常工作，先不管这个问题
```
python3 -c "from rknnlite.api import RKNNLite; r=RKNNLite(); print('NPU设备:', r.list_devices())"



- **它读了谁？** 日志显示程序读取了配置文件： `/usr/local/lib/python3.9/dist-packages/rknnlite/config/cpu_npu_mapper.yml` 这是 NPU 库的**“户口本”**，里面记录了它认识的所有板子名字。
    
- **它做了什么判断？** 读取完配置后，紧接着它去访问了： `/sys/bus/platform/devices/ffbc0000.npu` **`ffbc0000` 是 RK3568 的地址！**
    
- **结论：** NPU 库在查阅“户口本”时，发现你现在的名字（不管是伪装的还是真实的）不在 `rk3588` 的列表里，于是它启用了一个错误的默认逻辑，把你当成了 **RK3568**，导致找错了门。
  
  
# 1. 进入测试目录 cd /rockchip-test/npu2/ # 2. 运行演示脚本 ./rknn_demo.sh
  
  
```



## 网络设置
```
# 1. 创建固件目录
mkdir -p /lib/firmware/rtl8733bu

# 2. 拷贝固件 (假设固件在 /mnt/usb/firmware/ 下)
cp /mnt/usb/firmware/rtl8733bu_fw /lib/firmware/
cp /mnt/usb/firmware/rtl8733bu_config /lib/firmware/

# 3. 建立双保险软链接 (防止驱动找带 .bin 后缀的文件)
cp /lib/firmware/rtl8733bu_fw /lib/firmware/rtl8733bu_fw.bin
cp /lib/firmware/rtl8733bu_config /lib/firmware/rtl8733bu_config.bin

# 尝试插入内核模块
insmod /mnt/usb/modules/8733bu.ko

# 1. 扫描一下确认能搜到信号（可选）
nmcli dev wifi list

# 2. 连接 WiFi (使用你之前提供的信息)
nmcli dev wifi connect "H155-381_2AC8" password "fangwei123"

ping -c 4 baidu.com

# 1. 创建一个存放驱动的文件夹
mkdir -p /root/wifi_driver

# 2. 把 U 盘里的驱动复制过去 (假设 U 盘还在挂载中)
cp /mnt/usb/modules/8733bu.ko /root/wifi_driver/

# 3. 确认文件已经复制成功
ls -l /root/wifi_driver/8733bu.ko



sudo insmod /root/wifi_driver/8733bu.ko

sudo nmcli connection up "Xiaomi 14"

```

## SLAM环境部署测试
尝试在该系统下进行slam的验证

首先对slam的前置要求项目进行编译安装

```

#进行项目文件管理，创建文件夹，下载源码

mkdir -p projects/slam_libs 
cd projects/slam_libs
git clone https://github.com/stevenlovegrove/Pangolin.git 
cd Pangolin




#修改文件放置报错

nano CMakeLists.txt

- 按 `Ctrl + W` 进入搜索模式，输入 `-Werror` 并回车。
    
- 你应该会找到类似这样的一行： `add_compile_options(-Wall -Wextra -Werror)` 或者 `set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror")`
    
- **操作**：使用键盘的方向键移动光标，用 `Delete` 或 `Backspace` 键**只把 `-Werror` 这几个字删掉**。
    
- **结果**：这一行应该变成类似 `add_compile_options(-Wall -Wextra)`
  
  
  
  
  #尝试进行编译
  mkdir build && cd build
cmake ..
make -j4



#编译成功后进行安装
# 1. 把编译好的文件复制到 /usr/local/ 目录
sudo make install

# 2. 刷新系统的动态库缓存 (这步非常重要，否则系统可能找不到库)
sudo ldconfig

# 查看头文件是否存在，验证安装
ls /usr/local/include/pangolin/


#下载 ORB-SLAM3 源码
cd ~/projects 
# 1. 拉取源码 (如果不加加速镜像可能很慢，建议用这个 GitHub 加速地址) 
git clone https://github.com/UZ-SLAMLab/ORB_SLAM3.git 
# 2. 进入目录 
cd ORB_SLAM3

#解压文件
cd ~/projects 
# 1. 解压 
unzip ORB_SLAM3-master.zip 
# 2. 改名 
mv ORB_SLAM3-master ORB_SLAM3 
# 3. 进入目录 
cd ORB_SLAM3

#编译文件
#加脚本权限
chmod +x build.sh
#开始编译，修改内存核数
# 使用 sed 命令临时把脚本里的 make -j 改成 make -j4 
sed -i 's/make -j/make -j4/g' build.sh 
# 运行脚本 
./build.sh

#更新一些依赖，修改升级编译标准

nano CMakeLists.txt
# Check C++14 or C++0x support
include(CheckCXXCompilerFlag)
CHECK_CXX_COMPILER_FLAG("-std=c++14" COMPILER_SUPPORTS_CXX14)
CHECK_CXX_COMPILER_FLAG("-std=c++0x" COMPILER_SUPPORTS_CXX0X)
if(COMPILER_SUPPORTS_CXX14)
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++14")
   add_definitions(-DCOMPILEDWITHC11)
   message(STATUS "Using flag -std=c++14.")
elseif(COMPILER_SUPPORTS_CXX0X)
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x")
   add_definitions(-DCOMPILEDWITHC0X)
   message(STATUS "Using flag -std=c++0x.")
else()
   message(FATAL_ERROR "The compiler ${CMAKE_CXX_COMPILER} has no C++11 support>
endif()


#编译内存溢出崩溃

#使用虚拟内存
# 1. 创建一个 4GB 的空文件
fallocate -l 4G /swapfile

# 2. 设置权限
chmod 600 /swapfile

# 3. 格式化为 Swap 分区
mkswap /swapfile

# 4. 启用 Swap
swapon /swapfile

# 5. 确认是否生效 (看 Swap 那一行是不是有 4096M)
free -m



#单核编译测试
# 确保还在 build 目录 
cd ~/projects/ORB_SLAM3/build 
# 继续编译 
make -j1

#编译成功

#下载SLAM测试数据集
http://robotics.ethz.ch/~asl-datasets/ijrr_euroc_mav_dataset/machine_hall/MH_01_easy/MH_01_easy.zip

#使用adb进行文件传输

#解压文件，调试文件
#算法运行成功，生成轨迹数据
#下一步进行可视化

```

## ssh测试使用，解决板子网络问题
使用ssh连接传输似乎有一些硬件问题，导致ssh传输速度很慢，用U盘进行文件传输


## 使用U盘进行文件传输

```
#查找设备
fdisk -l

# 创建一个文件夹用来挂载 
mkdir -p /mnt/usb 
# 把 U 盘挂载上去 (注意替换 sda1) 
mount /dev/sda1 /mnt/usb

# 2. 复制文件 (瞬间完成) 
cp /mnt/usb/ORB_SLAM3-master.zip ~/projects/

#卸载U盘
umount /mnt/usb

```