---
title: 日志
date: 2025-11-13 12:08:00 +0800
layout: post
---
这是一份为你准备的《数字图像处理》开卷考试速查与复习资料。针对你提到的四个重点，我整理了**核心公式、解题步骤**以及**经典例题**。

开卷考试的特点是“重思路、重步骤”，所以我在下面使用了表格和分步推导，方便你快速查阅。

---

### 第一部分：直方图均衡化 (Histogram Equalization)

**考点核心：** 将原图集中的灰度分布，映射到整个灰度范围，增强对比度。

#### 1. 核心公式与步骤

假设图像总像素数为 $N$，灰度级为 $L$ (通常 $L=256$，即0-255；考试有时会用 $L=8$，即0-7)。

1. **统计：** 计算每个灰度级 $r_k$ 出现的次数 $n_k$。
    
2. **归一化（计算概率）：** $p_r(r_k) = \frac{n_k}{N}$
    
3. **计算累计分布函数 (CDF)：** $S_k = \sum_{j=0}^{k} p_r(r_j)$
    
4. **映射与取整：** $s_k = \text{round}[(L-1) \times S_k]$
    
    - 注意：$\text{round}$ 表示四舍五入到最近的整数。
        

#### 2. 经典例题（必看）

**题目：** 假设有一幅 $64 \times 64$ 像素的图像 ($N=4096$)，灰度级为 8 级 ($0 \sim 7$)。灰度分布如下表，请计算均衡化后的灰度值。

|**灰度级 rk​**|**像素数 nk​**|
|---|---|
|0|790|
|1|1023|
|2|850|
|3|656|
|4|329|
|5|245|
|6|122|
|7|81|

**解题过程（考试直接画这个表）：**

1. **总像素 $N$** = 4096
    
2. **最大灰度 $L-1$** = 7
    

|**rk​ (原灰度)**|**nk​ (数量)**|**pr​(rk​)=nk​/N (概率)**|**Sk​ (累计概率)**|**(L−1)×Sk​ (计算映射)**|**sk​ (四舍五入后新灰度)**|
|---|---|---|---|---|---|
|**0**|790|0.19|0.19|$7 \times 0.19 = 1.33$|**1**|
|**1**|1023|0.25|$0.19+0.25=0.44$|$7 \times 0.44 = 3.08$|**3**|
|**2**|850|0.21|$0.44+0.21=0.65$|$7 \times 0.65 = 4.55$|**5**|
|**3**|656|0.16|$0.65+0.16=0.81$|$7 \times 0.81 = 5.67$|**6**|
|**4**|329|0.08|$0.81+0.08=0.89$|$7 \times 0.89 = 6.23$|**6**|
|**5**|245|0.06|$0.89+0.06=0.95$|$7 \times 0.95 = 6.65$|**7**|
|**6**|122|0.03|$0.95+0.03=0.98$|$7 \times 0.98 = 6.86$|**7**|
|**7**|81|0.02|$0.98+0.02=1.00$|$7 \times 1.00 = 7.00$|**7**|

**最终映射关系：** $0 \to 1, 1 \to 3, 2 \to 5, 3 \to 6, 4 \to 6, 5 \to 7, 6 \to 7, 7 \to 7$。

---

### 第二部分：HDR (高动态范围) 技术

**考点核心：** 概念理解与处理流程（通常不考复杂计算，主要考流程原理）。

#### 1. 核心概念

- **动态范围 (Dynamic Range):** 场景中从最亮到最暗的光照强度比值。
    
- **问题：** 普通相机（SDR）只有8位（0-255），无法同时记录极亮和极暗的细节。
    
- **HDR原理：** 使用32位浮点数记录亮度，远超人眼识别范围。
    

#### 2. HDR 生成三步曲（答题模板）

如果考简答题或流程题，按这个顺序写：

1. **多重曝光获取 (Acquisition):**
    
    - 拍摄多张不同曝光时间（Shutter Speed）的照片（欠曝拍高光，过曝拍阴影）。
        
2. **合成 (Merging/Fusion):**
    
    - 将这些照片合成为一张 **辐照度图 (Irradiance Map)**。
        
    - 利用**相机响应函数 (CRF)** 恢复真实的线性亮度值。
        
    - _常用算法关键词：Debevec算法。_
        
3. **色调映射 (Tone Mapping) [最重要的一步]:**
    
    - **目的：** HDR图像也是32位数据，普通显示器只能显示8位。必须把“宽范围”压缩回“窄范围”才能显示。
        
    - **方法：**
        
        - **全局映射 (Global):** 对全图用同一个函数压缩（如对数变换 $y = \log(x)$）。简单但容易丢细节。
            
        - **局部映射 (Local):** 根据邻域像素调整，保留局部对比度（看起来更清楚）。
            

---

### 第三部分：霍夫曼编码 (Huffman Coding)

**考点核心：** 变长编码，概率越大编码越短。

#### 1. 解题算法（造树法）

1. **排序：** 将所有符号按概率从小到大排列。
    
2. **合并：** 取出概率**最小的两个**节点，将其相加形成一个新节点（新概率为两者之和）。
    
3. **重复：** 将新节点放回列表中重新排序，重复步骤2，直到只剩一个根节点（概率和为1）。
    
4. **编码：** 画出二叉树，左分支标 0，右分支标 1（或反之，只要统一即可）。
    

#### 2. 经典例题

**题目：** 对符号集 $\{a_1, a_2, a_3, a_4, a_5\}$ 进行霍夫曼编码，概率分别为 $\{0.4, 0.2, 0.2, 0.1, 0.1\}$。

**解题过程：**

- **第1步：** 排序 $\{0.1, 0.1, 0.2, 0.2, 0.4\}$
    
    - 最小的是 $a_4(0.1)$ 和 $a_5(0.1)$。
        
    - 合并 $\to 0.2$。
        
- **第2步：** 新列表 $\{0.2(\text{新}), 0.2(a_2), 0.2(a_3), 0.4(a_1)\}$
    
    - 最小的是 $0.2(\text{新})$ 和 $a_2(0.2)$ (顺序无所谓)。
        
    - 合并 $\to 0.4$。
        
- **第3步：** 新列表 $\{0.2(a_3), 0.4(\text{新}), 0.4(a_1)\}$
    
    - 最小的是 $a_3(0.2)$ 和 $0.4(\text{新})$。
        
    - 合并 $\to 0.6$。
        
- **第4步：** 新列表 $\{0.4(a_1), 0.6(\text{新})\}$
    
    - 合并 $\to 1.0$。
        

**树结构与编码（假设左0右1）：**

- $a_1 (0.4) \to$ **0**
    
- $a_2 (0.2) \to$ **10**
    
- $a_3 (0.2) \to$ **110**
    
- $a_4 (0.1) \to$ **1110**
    
- $a_5 (0.1) \to$ 1111
    
    (注：具体编码值取决于你合并时的左右摆放，但码长是固定的：概率越小，码长越长)
    

平均码长计算：

$L_{avg} = \sum p(a_i) \times \text{length}(a_i)$

$L_{avg} = 0.4\times1 + 0.2\times2 + 0.2\times3 + 0.1\times4 + 0.1\times4 = 0.4 + 0.4 + 0.6 + 0.4 + 0.4 = 2.2 \text{ bits/symbol}$

---

### 第四部分：算术编码 (Arithmetic Coding)

**考点核心：** 将整个消息编码为一个实数区间 $[0, 1)$ 中的一个数值。

#### 1. 核心公式

新区间 = 旧区间下界 + (旧区间长度 $\times$ 当前符号的累计概率范围)

- $Low_{new} = Low_{old} + Range_{old} \times Low\_Range(Symbol)$
    
- $High_{new} = Low_{old} + Range_{old} \times High\_Range(Symbol)$
    

#### 2. 经典例题

**题目：** 设信源符号为 $\{A, B, C\}$，概率分别为 $P(A)=0.2, P(B)=0.3, P(C)=0.5$。请对序列 **"BAC"** 进行编码。

**解题准备（画出初始区间）：**

- A: $[0, 0.2)$
    
- B: $[0.2, 0.5)$ (因为 $0.2+0.3=0.5$)
    
- C: $[0.5, 1.0)$
    

编码过程：

初始状态： 区间 $[0, 1)$，长度 $Range = 1$。

1. **输入符号 'B' (对应范围 $[0.2, 0.5)$):**
    
    - $Low = 0 + 1 \times 0.2 = 0.2$
        
    - $High = 0 + 1 \times 0.5 = 0.5$
        
    - **当前区间：** $[0.2, 0.5)$，**当前长度：** $0.3$
        
2. **输入符号 'A' (对应范围 $[0, 0.2)$):**
    
    - 这里要在上一步的区间 $[0.2, 0.5)$ 里面，按比例截取 A 的那一段。
        
    - $Low = 0.2 + 0.3 \times 0.0 = 0.2$
        
    - $High = 0.2 + 0.3 \times 0.2 = 0.26$
        
    - **当前区间：** $[0.2, 0.26)$，**当前长度：** $0.06$
        
3. **输入符号 'C' (对应范围 $[0.5, 1.0)$):**
    
    - 这里要在上一步的区间 $[0.2, 0.26)$ 里面，按比例截取 C 的那一段。
        
    - $Low = 0.2 + 0.06 \times 0.5 = 0.23$
        
    - $High = 0.2 + 0.06 \times 1.0 = 0.26$
        
    - **最终区间：** $[0.23, 0.26)$
        

输出结果：

该序列 "BAC" 可以由区间 $[0.23, 0.26)$ 内的任意一个小数表示（例如 0.24 或 0.25）。在计算机中，通常会输出该区间的二进制形式。

---

### 开卷考试 Tips

1. **直方图均衡化：** 别忘了最后一步要**四舍五入**！并且检查所有像素的概率加起来是否等于1（或者累计概率最后是1），用来验算。
    
2. **霍夫曼编码：** 只要考画图，务必把树画大一点，清楚标出0和1。计算平均码长是拿分点。
    
3. **算术编码：** 计算小数很容易出错，**带上计算器**，保留足够的小数位（建议保留4-5位）。如果区间变成负数或者大于1，说明算错了。
    

需要我为你提供这几个部分的**练习题**或者更详细的**代码实现**（如果是机考）吗？

没问题。既然是为了应对**开卷考试**，你需要的内容不仅要有计算步骤，还需要有**标准定义、原理背景、优缺点**等理论性的描述，以便应对名词解释或简答题。

这就为你生成一份**“百科全书式”**的复习资料，内容更详尽、学术化，适合直接查阅和引用。

---

# 数字图像处理：开卷考试核心考点速查手册

## 第一部分：直方图均衡化 (Histogram Equalization)

### 1. 定义 (Definition)

直方图均衡化是一种用于**增强图像对比度**的图像处理技术。它通过对图像的灰度直方图进行变换，使变换后的图像直方图分布变得均匀（即每个灰度级出现的概率近似相等），从而扩展了像素灰度的动态范围，增加了图像的整体对比度。

### 2. 基本原理 (Principle)

- **数学基础：** 基于概率论中的**累计分布函数 (CDF)**。
    
- **核心思想：** 将原图像中分布密集的灰度级“拉伸”，将分布稀疏的灰度级“合并”或“压缩”。
    
- **变换函数：** 设 $r$ 为原图像灰度，$s$ 为变换后灰度，变换函数 $s = T(r)$ 需满足单调递增，且 $0 \le s \le L-1$。
    
- 公式：
    
    $$s_k = T(r_k) = (L-1) \sum_{j=0}^{k} p_r(r_j)$$
    
    其中：
    
    - $r_k$：输入图像的第 $k$ 级灰度。
        
    - $L$：灰度级总数（通常为256）。
        
    - $p_r(r_j)$：第 $j$ 级灰度出现的概率（即归一化直方图）。
        
    - $\sum p_r(r_j)$：累计分布函数 (CDF)。
        

### 3. 详细计算步骤 (标准解题流程)

假设图像大小为 $M \times N$，灰度级为 $L$。

1. **统计直方图：** 计算原图中每个灰度级 $r_k$ 出现的像素个数 $n_k$。
    
2. **计算概率密度：** 计算每个灰度级的概率 $p_r(r_k) = \frac{n_k}{M \times N}$。
    
3. **计算累计概率 (CDF)：** 计算 $S_k = \sum_{j=0}^{k} p_r(r_j)$。即当前的概率加上前面所有灰度级的概率。
    
4. **计算映射值：** 计算 $(L-1) \times S_k$。
    
5. **取整输出：** 对上一步结果进行四舍五入，得到新的灰度级 $s_k = \text{round}[(L-1)S_k]$。
    

### 4. 优缺点 (简答题考点)

- **优点：** 算法简单，无须参数，能自动增强对比度，使图像细节更清晰。
    
- **缺点：** 可能会导致背景噪声对比度增加；对于直方图原本就很密集的图像（如全黑或全白），效果可能不自然（出现伪轮廓）。
    

---

## 第二部分：HDR (高动态范围成像) 技术

### 1. 定义 (Definition)

HDR (High Dynamic Range Imaging) 是一种用来实现比普通数字图像技术更大**曝光动态范围**（即最亮和最暗部分的比例）的一组技术。

- **LDR (Low Dynamic Range):** 普通图像（JPG/PNG），通常为8位，灰度范围 0-255。
    
- **HDR:** 使用32位浮点数存储亮度值，能同时记录阳光下的极亮和阴影下的极暗细节。
    

### 2. 核心处理流程 (Process)

考试若问“HDR的实现步骤”，请按以下三点回答：

#### (1) 获取 (Acquisition) / 多重曝光

由于普通传感器动态范围有限，通常拍摄**多张不同曝光时间**的照片（一张欠曝保留高光细节，一张过曝保留阴影细节，一张正常曝光）。

#### (2) 合成与辐射度校准 (Fusion & Radiometric Calibration)

- **相机响应函数 (CRF):** 相机记录的像素值 $Z$ 与实际光照 $E$ 之间是非线性的。需要求出这个反函数 $g(Z) = \ln(E \cdot \Delta t)$。
    
- **合成：** 利用CRF将多张照片的像素值反推回真实的物理光照强度（Irradiance），并加权平均，生成一张**辐射度图 (Irradiance Map)**。这张图通常是32位浮点数据。
    

#### (3) 色调映射 (Tone Mapping) —— **这是考点重点**

- **定义：** 将高动态范围（HDR）的数据压缩到低动态范围（LDR）的显示设备（如显示器）上进行显示的过程。
    
- **分类：**
    
    - **全局算子 (Global Operators):** 对图像中每个像素使用相同的非线性函数（如对数变换、Gamma变换）。计算快，但容易导致局部对比度丢失。
        
    - **局部算子 (Local Operators):** 根据像素邻域的亮度信息进行自适应调整。能很好地保留局部细节，但计算量大，可能产生光晕 (Halo) 效应。
        

---

## 第三部分：霍夫曼编码 (Huffman Coding)

### 1. 定义 (Definition)

霍夫曼编码是一种基于统计概率的**无损数据压缩**算法，由David Huffman于1952年提出。它是一种**变长编码 (Variable-Length Code)**，属于**熵编码**的一种。

### 2. 核心原理 (Principle)

- **概率决定码长：** 出现概率高的符号使用较短的编码，出现概率低的符号使用较长的编码，从而使平均码长最短。
    
- **前缀性质 (Prefix Property):** 任何一个字符的编码都不是另一个字符编码的前缀。这保证了在解码时不会产生歧义（无需分隔符）。
    
- **最优性：** 在针对独立信源进行符号级编码时，霍夫曼编码是理论上最优的。
    

### 3. 构建霍夫曼树的步骤 (Algorithm)

1. **初始化：** 将信源符号按概率从小到大排列，每个符号看作一个叶子节点。
    
2. **合并：** 选取概率**最小**的两个节点作为左右子树，构造一个新的父节点，父节点的概率为这两个子节点概率之和。
    
3. **重排：** 将原来的两个小节点删除，将新的父节点加入队列，重新按概率排序。
    
4. **循环：** 重复步骤2和3，直到队列中只剩下一个节点（根节点，概率为1）。
    
5. **分配码字：** 约定左分支为0，右分支为1（或反之），从根节点走到叶子节点，记录路径上的0/1序列即为该符号的编码。
    

### 4. 详解例题 (按此格式答题)

**题目：** 对字符串 "BCAAB" 进行霍夫曼编码。

- 符号统计：A: 2次 (0.4), B: 2次 (0.4), C: 1次 (0.2)。
    

**步骤：**

1. **排序：** $C(0.2) < A(0.4) = B(0.4)$
    
2. **第一轮合并：**
    
    - 取最小的两个：由于只有3个，最小的是 C(0.2) 和 A(0.4) [注：也可以选B，结果不同但长度效率一样]。
        
    - 合并产生新节点 $N_1$，概率 = $0.2 + 0.4 = 0.6$。
        
    - 当前池子：$B(0.4), N_1(0.6)$。
        
3. **第二轮合并：**
    
    - 取 $B(0.4)$ 和 $N_1(0.6)$。
        
    - 合并产生根节点 $Root$，概率 = $1.0$。
        

**画树与编码：**

```
      [Root: 1.0]
      /        \
   B(0.4)    [N1: 0.6]
             /      \
          C(0.2)   A(0.4)
```

_(假设左0右1)_

- **B:** 0
    
- **C:** 10
    
- **A:** 11
    

平均码长计算：

$L_{avg} = 0.4 \times 1 + 0.2 \times 2 + 0.4 \times 2 = 1.6 \text{ bits}$

---

## 第四部分：算术编码 (Arithmetic Coding)

### 1. 定义 (Definition)

算术编码是一种**无损熵编码**方法。与霍夫曼编码将每个符号单独映射成二进制串不同，算术编码将**整个消息序列**映射为实数轴上区间 $[0, 1)$ 内的一个**实数**（通常是一个小数）。

### 2. 核心原理 (Principle)

- **区间细分：** 初始区间为 $[0, 1)$。每读入一个符号，就根据该符号的概率，将当前区间按比例缩小。
    
- **概率与区间：** 符号的概率越大，分配给它的子区间越宽，编码所需的位数就越少。
    
- **结束：** 编码结束时，输出最终区间内的任意一个数（通常是最短的二进制小数）作为编码结果。
    

### 3. 递推公式 (必背)

设当前区间为 $[Low, High)$，当前区间长度 $Range = High - Low$。

符号 $x$ 的概率为 $P(x)$，其在累计概率表中的范围是 $[CDF_{low}(x), CDF_{high}(x))$。

- **新的下界：** $Low_{new} = Low + Range \times CDF_{low}(x)$
    
- **新的上界：** $High_{new} = Low + Range \times CDF_{high}(x)$
    

### 4. 详解例题 (表格法)

**题目：** 符号集 $\{a, b, c\}$，概率 $\{0.6, 0.2, 0.2\}$。求序列 **"bcc"** 的编码。

**准备阶段：建立累计概率表**

- **a:** $[0.0, 0.6)$
    
- **b:** $[0.6, 0.8)$ (因为 $0.6+0.2=0.8$)
    
- **c:** $[0.8, 1.0)$
    

**编码过程：**

|**步骤**|**输入符号**|**原区间 [Low,High)**|**区间宽度 Range**|**计算过程**|**新区间**|
|---|---|---|---|---|---|
|Start|-|$[0.0, 1.0)$|1.0|-|-|
|1|**b**|$[0.0, 1.0)$|1.0|$L = 0 + 1 \times 0.6 = 0.6$<br><br>  <br><br>$H = 0 + 1 \times 0.8 = 0.8$|$[0.6, 0.8)$|
|2|**c**|$[0.6, 0.8)$|0.2|**注：c的范围是 $[0.8, 1.0)$**<br><br>  <br><br>$L = 0.6 + 0.2 \times 0.8 = 0.76$<br><br>  <br><br>$H = 0.6 + 0.2 \times 1.0 = 0.80$|$[0.76, 0.8)$|
|3|**c**|$[0.76, 0.8)$|0.04|**注：c的范围是 $[0.8, 1.0)$**<br><br>  <br><br>$L = 0.76 + 0.04 \times 0.8 = 0.792$<br><br>  <br><br>$H = 0.76 + 0.04 \times 1.0 = 0.800$|$[0.792, 0.8)$|

最终结果：

序列 "bcc" 可以用区间 $[0.792, 0.8)$ 之间的任意数值表示（例如 0.795）。

解码验证 (如果考解码)：

拿到 0.795：

1. 0.795 落在 $[0.6, 0.8)$ 之间 $\to$ 第一个符号是 **b**。
    
2. 去掉 b 的影响：$(0.795 - 0.6) / 0.2 = 0.975$。
    
3. 0.975 落在 $[0.8, 1.0)$ 之间 $\to$ 第二个符号是 **c**。
    
4. 去掉 c 的影响：$(0.975 - 0.8) / 0.2 = 0.875$。
    
5. 0.875 落在 $[0.8, 1.0)$ 之间 $\to$ 第三个符号是 **c**。
    

---

希望这份“定义+原理+步骤”的详细资料能更符合你的开卷考试需求！祝考试顺利！

![](矩阵论复习选讲2024版.pdf)